---
title: "[Java] Collection / Annotation / Generic 정리"
excerpt: "cs 공부"

categories:
  - CS
tags:
  - [java]

permalink: /cs/cs-java-1/

toc: true
toc_sticky: true

date: 2023-03-27
last_modified_at: 2023-03-27
---

> JaeYeopHan님의 자료를 바탕으로 정리한 글입니다

- [출처](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#collection)

<br>

# Collection

- Java Collection

  - `List`, `Map`, `Set` 인터페이스를 기준으로 여러 구현체 존재
  - `Stack`과 `Queue` 인터페이스도 존재
  - 이러한 Collection을 사용하는 이유
    - 다수의 Data를 다루는 데 표준화된 클래스들을 제공해주기 때문에
      - Data Structure를 **직접 구현하지 않고 편하게 사용할 수 있기 때문**
    - 배열과 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로
      - 상황에 따라 객체의 수를 동적으로 정할 수 있음
        - 이는 프로그램의 공간적인 효율성 또한 높여줌

- List

  - `List` 인터페이스를 직접 `@Override`를 통해 사용자가 정의하여 사용할 수 있음
    - 대표적인 구현체: `ArrayList`
      - 이는 기존에 있었던 `Vector`를 개선한 것
        - 오브젝트에서 `Vector`와 `Stack`과의 관계에 대해서 읽은 적이 있는데
        - 막상 쓰지 않는 이유는 `ArrayList`였구나 👀
    - 이외에도 `LinkedList` 등의 구현체 존재

- Map

  - 대표적인 구현체: `HashMap`
  - key-value의 구조로 이루어져 있음
    - Map에 대한 구체적인 내용은 Data Structure 부분의 Hash Table과 일치
  - key를 기준으로 중복된 값을 저장하지 않으며 순서를 보장하지 않음
    - 순서를 보장해주기 위해 `LinkedHashMap` 사용
      - 이건 파이썬에만 있는 줄 알았는데 아니었구나

- Set

  - 대표적인 구현체: `HashSet`
  - value에 대해 중복된 값을 저장하지 않음
  - Set 자료구조는 Map의 key-value 구조에서
    - key 대신 value가 들어가 value를 key로 하는 자료구조일 뿐임
      - 마찬가지로 순서를 보장해주기 위해 `LinkedHashSet` 사용
        - 이건 예전에 프로그래머스 문제 풀면서 사용해본 적 있음!

- Stack과 Queue

  - `Stack` 객체는 직접 `new` 키워드로 사용할 수 있음
  - `Queue` 인터페이스는 JDK 1.5부터 `Linkedlist`에 `new` 키워드를 적용하여 사용할 수 있음

# Annotation

- 어노테이션: 본래 주석이란 뜻으로, 인터페이스를 기반으로한 문법
- 주석과는 그 역할이 다르지만

  - 주석처럼 코드에 달아서 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있음
  - 해석되는 시점을 정할 수도 있음

- 어노테이션에는 크게 세 가지 종류가 존재
  - JDK에 내장되어 있는 `built-in annotation`|
    - 상속을 받아서 메서드를 오버라이딩 할 때 나타나는 `@Override` 어노테이션이 그 예
  - 정보를 나타내기 위한 `Meta annotation`
    - 어노테이션의 동작 대상을 결정하고, 여러 가지가 존재함
  - 개발자가 직접 만들어 내는 `Custom Annotaiton`

# Generic

- 제네릭은 자바에서 **안정성**을 맡고 있음

- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로

  - 컴파일 과정에서 타입 체크를 해주는 기능

- 객체의 타입을 **컴파일 시에 체크**하기 때문에
  - 객체의 타입 안정성을 높이고 형변환은 번거로움을 줄여줌 -> 자연스럽게 코드도 더 간결해짐
    - 예를 들어
      - Collection에 특정 객체만 추가될 수 있도록
      - 특정한 클래스의 특징을 갖고 있는 경우에만 추가할 수 있도록 함
    - 이로 인한 장점
      - Collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직 처리를 구현할 필요가 없어짐
      - API를 설계하는 데 있어서, 보다 명확한 의사 전달이 가능해짐
